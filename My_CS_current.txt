================================================================
RepopackPy Output File
================================================================

This file was generated by RepopackPy on: 2025-08-11T15:15:01.594195

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and RepopackPy's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

For more information about RepopackPy, visit: https://github.com/abinthomasonline/repopack-py

================================================================
Repository Structure
================================================================
boards\nrf54l15dk_nrf54l15_cpuapp.overlay
boards\nrf54l15tag_nrf54l15_cpuapp.overlay
boards\nrf54l15zhiyuan_nrf54l15_cpuapp.overlay
lib\CMakeLists.txt
lib\black_box\coreaiot_distance.h
lib\black_box\libcoreaiot_distance.a
lib\ble\ble.c
lib\ble\ble.h
lib\calc\calc.c
lib\calc\calc.h
lib\calc_black_box\calc_black_box.c
lib\calc_black_box\calc_black_box.h
lib\cs\cs.c
lib\cs\cs.h
lib\global.h
lib\sync\sync.c
lib\sync\sync.h
projects\initator_build\CMakeLists.txt
projects\initator_build\Kconfig
projects\initator_build\prj.conf
projects\reflector_build\CMakeLists.txt
projects\reflector_build\Kconfig
projects\reflector_build\prj.conf
src\initator.c
src\reflector.c

================================================================
Repository Files
================================================================

================
File: boards\nrf54l15dk_nrf54l15_cpuapp.overlay
================
/*
 * Copyright (c) 2025 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

/ {
	cs_antenna_switch: cs-antenna-config {
		status = "okay";
		compatible = "nordic,bt-cs-antenna-switch";
		ant-gpios = <&gpio1 10 (GPIO_ACTIVE_HIGH)>,
			    <&gpio1 14 (GPIO_ACTIVE_HIGH)>;
		multiplexing-mode = <0>;
	};
};

================
File: boards\nrf54l15tag_nrf54l15_cpuapp.overlay
================
/*
 * Copyright (c) 2025 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

/ {
	cs_antenna_switch: cs-antenna-config {
		status = "okay";
		compatible = "nordic,bt-cs-antenna-switch";
		ant-gpios = <&gpio1 9 (GPIO_ACTIVE_HIGH)>,
			    <&gpio1 10 (GPIO_ACTIVE_HIGH)>;
		multiplexing-mode = <0>;
	};
};

================
File: boards\nrf54l15zhiyuan_nrf54l15_cpuapp.overlay
================
/*
 * Copyright (c) 2025 Nordic Semiconductor ASA
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

/ {
	cs_antenna_switch: cs-antenna-config {
		status = "okay";
		compatible = "nordic,bt-cs-antenna-switch";
		ant-gpios = <&gpio0 1 (GPIO_ACTIVE_LOW)>,
			    <&gpio0 0 (GPIO_ACTIVE_LOW)>;
		multiplexing-mode = <0>;
	};
};

================
File: lib\CMakeLists.txt
================
find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})

# Channel Sounding 
add_library(cs cs/cs.c)
target_include_directories(cs PUBLIC cs ${ZEPHYR_BASE}/include)
target_link_libraries(cs PUBLIC zephyr_interface calc calc_black_box)

# Bluetooth 
add_library(ble ble/ble.c)
target_include_directories(ble PUBLIC ble ${ZEPHYR_BASE}/include)
target_link_libraries(ble PUBLIC zephyr_interface cs sync)

# Distance calculation 
add_library(calc calc/calc.c)
target_include_directories(calc PUBLIC calc ${ZEPHYR_BASE}/include)
target_link_libraries(calc PUBLIC zephyr_interface)

# Synchronization 
add_library(sync sync/sync.c)
target_include_directories(sync PUBLIC sync ${ZEPHYR_BASE}/include)
target_link_libraries(sync PUBLIC zephyr_interface)

# Black box 
add_library(black_box INTERFACE)
target_link_libraries(black_box INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/black_box/libcoreaiot_distance.a)
target_include_directories(black_box INTERFACE ${CMAKE_CURRENT_SOURCE_DIR}/black_box)

# Distance calculation Black box version 
add_library(calc_black_box calc_black_box/calc_black_box.c)
target_include_directories(calc_black_box PUBLIC calc_black_box ${ZEPHYR_BASE}/include)
target_link_libraries(calc_black_box PUBLIC zephyr_interface black_box)

================
File: lib\global.h
================
#pragma once 

#define ID 0
#define DE_SLIDING_WINDOW_SIZE (10)
#define MAX_AP (CONFIG_BT_RAS_MAX_ANTENNA_PATHS)
#define REFLECTOR_NAME "1234"
#define INITIATOR_NAME "5678"
#define BUILD_INITIATOR CONFIG_CS_BUILD_INITIATOR
#define BUILD_REFLECTOR CONFIG_CS_BUILD_REFLECTOR
#define USING_BLACK_BOX CONFIG_CS_BLACK_BOX_CALC
#define PROCEDURE_COUNTER_NONE (-1)
#define SLOT_DURATION 500

#define LOCAL_PROCEDURE_MEM                                                                        \
	((BT_RAS_MAX_STEPS_PER_PROCEDURE * sizeof(struct bt_le_cs_subevent_step)) +                \
	 (BT_RAS_MAX_STEPS_PER_PROCEDURE * BT_RAS_MAX_STEP_DATA_LEN))

#define TRY_BASE(func, ...) \
    do { \
        int err = func; \
        if (err) { \
            __VA_ARGS__; \
        } \
    } while(0)

#define TRY(func) \
    TRY_BASE(func, printk("Failed to run %s: (error %d)\n", #func, err))

#define TRY_GOTO(func, place) \
    TRY_BASE(func, goto place)

#define TRY_RETURN(func) \
    TRY_BASE(func, \
        printk("Failed to run %s: (error %d)\n", #func, err); \
        return err)

================
File: lib\black_box\coreaiot_distance.h
================
#ifndef COREAOIT_DISTANCE_H_
#define COREAOIT_DISTANCE_H_

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>

struct bt_le_cs_iq_sample_replica {
	int16_t i;
	int16_t q;
};
struct iq_sample_and_channel_replica {
	bool failed;
	uint8_t channel;
	uint8_t antenna_path;
	struct bt_le_cs_iq_sample_replica local_iq_sample;
	struct bt_le_cs_iq_sample_replica peer_iq_sample;
};
/**
 * @brief Estimate the distance based on IQ samples and channel information using CoreAIOT algorithm.
 *
 * This function calculates the distance between devices by analyzing the IQ samples,
 * and other parameters such as antenna path and frequency compensation. It implements a multi-step 
 * signal processing pipeline to improve accuracy and robustness in various propagation conditions.
 *
 * @param data Pointer to an array of IQ sample data and channel/antenna path.
 * @param len Length of the `data` array (number of IQ samples).
 * @param ant_path Antenna path used for the measurement (start from 0).
 * @param samples_cnt Pointer to a variable where the number of valid IQ samples will be stored.
 * @param most_recent_frequency_compensation Frequency compensation value from the latest calibration. 
 * ref to frequency_compensation in the header of bt_conn_le_cs_subevent_result
 * @param tag_idx Index of the tag for which distance is being estimated (used for internal state tracking, start from 0).
 *
 * @return Estimated distance in centimeters. Returns zero if the hardware is not supported.
 */
float estimate_distance_coreaiot(struct iq_sample_and_channel_replica *data, 
	uint8_t len, 
	uint8_t ant_path,
	uint8_t *samples_cnt,
	uint16_t most_recent_frequency_compensation, 
	int tag_idx);

#endif /* COREAOIT_DISTANCE_H_ */

================
File: lib\ble\ble.c
================
#include "ble.h"

struct ble_ctx ble_info; 
struct semaphores_ctx semaphores; 
struct ble_state_handler ble_state; 
extern atomic_t write_busy; 


#if BUILD_REFLECTOR
static struct bt_conn *active_conn = NULL; 
static bool indication_busy; 
static int turn_idx = 0; 

static const struct bt_le_conn_param ble_param = {
    .interval_min = 40, 
    .interval_max = 40, 
    .latency = 0, 
    .timeout = 500,
}; 

const static struct bt_le_scan_param search_param = {
    .type = BT_HCI_LE_SCAN_ACTIVE, 
    .options = BT_LE_SCAN_OPT_NONE,
    .interval = 20,
    .window = 6
};

static struct bt_scan_init_param scan_param = {
    .connect_if_match = true, 
    .scan_param = &search_param, 
    .conn_param = BT_LE_CONN_PARAM_DEFAULT,
};

struct cs_config_item {
    void *fifo_reserved;  
    struct bt_conn *conn;
    bool enable;  // true = configure CS, false = cleanup CS
};
#endif 

#if BUILD_INITIATOR
struct indicate_handler indicate_ctx;

static struct bt_gatt_dm_cb gatt_callbacks = {
    .completed = dm_completed, 
    .service_not_found = dm_service_not_found, 
    .error_found = dm_error_found, 
};



static struct bt_gatt_exchange_params mtu_exchange_params = {.func = mtu_exchange_cb};

static const struct bt_data adv[] = {
  BT_DATA_BYTES(BT_DATA_FLAGS, BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR),
  BT_DATA_BYTES(BT_DATA_UUID16_ALL,
                BT_UUID_16_ENCODE(BT_UUID_RANGING_SERVICE_VAL)),
  BT_DATA_BYTES(BT_DATA_UUID128_ALL, SYNC_SERVICE_UUID_VAL),
};

static const struct bt_data scan_rsp[] = {
  BT_DATA(BT_DATA_NAME_COMPLETE, INITIATOR_NAME,
          sizeof(INITIATOR_NAME) - 1),
};
#endif 

/**********************************************************************/
/*                           CALLBACKS                                */
/**********************************************************************/

BT_CONN_CB_DEFINE(conn_callbacks) = {
    .connected = connected,
    .disconnected = disconnected,
    .security_changed = security_changed,
    .le_phy_updated = phy_changed_cb, 
};


void connected(struct bt_conn *conn, uint8_t err) {
    char addr[BT_ADDR_LE_STR_LEN];

    (void)bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
    printk("Connected to %s (err %d)\n", addr, err);

    if (err) {
        printk("Failed to connect to %s (err %d)\n", addr, err);

        #if BUILD_REFLECTOR 
        for (int i = 0; i < CONFIG_BT_MAX_CONN; i++) {
            if (ble_info.connections[i] == conn) {
                bt_conn_unref(ble_info.connections[i]);
                ble_info.connections[i] = NULL;
                ble_info.conn_count--;
                printk("Connection slot %d freed\n", i);
                break;
            }
        }
        #endif 

        #if BUILD_INITIATOR 
        bt_conn_unref(conn);
        conn = NULL; 
        ble_info.connection = NULL; 
        #endif 
        return; 
    }

    #if BUILD_REFLECTOR 
    for (int i = 0; i < CONFIG_BT_MAX_CONN; i++) {
        if (ble_info.connections[i] == NULL) {
            ble_info.connections[i] = bt_conn_ref(conn);
            ble_info.conn_count++;
            printk("Connection slot %d assigned\n", i);

            TRY(bt_conn_le_param_update(conn, &ble_param));
            ble_set_phy(conn);
            configure_cs_connection(conn);
            dk_set_led_on(DK_LED1 + i);
            break;
        }
    }

    if (ble_info.conn_count == CONFIG_BT_MAX_CONN) {
        TRY(bt_le_scan_stop()); 
        ble_update_state(INACTIVE_SCAN); 
    } else {
        TRY(bt_scan_start(BT_SCAN_TYPE_SCAN_ACTIVE)); // TODO: Better check to stop starting in cases where its still on
        ble_update_state(ACTIVE_SCAN); 
    }
    #endif 

    #if BUILD_INITIATOR 
    ble_info.connection = bt_conn_ref(conn); 
    dk_set_led_on(DK_LED1);

    TRY(bt_le_adv_stop());
    ble_update_state(INACTIVE_ADV);
    #endif 
 
    k_sem_give(&semaphores.connected);
}

void disconnected(struct bt_conn *conn, uint8_t reason) {
    char addr[BT_ADDR_LE_STR_LEN];

    (void)bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
    printk("Disconnected from %s (reason 0x%02x)\n", addr, reason);

    #if BUILD_REFLECTOR
    if (conn == active_conn) {
        active_conn = NULL; 
        indication_busy = false; 
    }

    for(int i = 0; i < CONFIG_BT_MAX_CONN; i++) {
        if (ble_info.connections[i] == conn) {
            bt_conn_unref(ble_info.connections[i]);
            ble_info.connections[i] = NULL;
            dk_set_led_off(DK_LED1 + i); 
            ble_info.conn_count--;
            printk("Connection slot %d freed\n", i);
            break;
        }
    }

    if (ble_info.conn_count < CONFIG_BT_MAX_CONN) {
        TRY(bt_scan_start(BT_SCAN_TYPE_SCAN_ACTIVE)); // TODO: Better check to stop starting in cases where its still on
        ble_update_state(ACTIVE_SCAN); 
    } 
    #endif 

    #if BUILD_INITIATOR 
    bt_conn_unref(conn);
    ble_info.connection = NULL; 

    cs_reset_state(); 
    TRY(ble_adv_start());
    ble_update_state(ACTIVE_ADV); 
    #endif
}

void security_changed(struct bt_conn *conn, bt_security_t level, enum bt_security_err err) {
    char addr[BT_ADDR_LE_STR_LEN];

    (void)bt_addr_le_to_str(bt_conn_get_dst(conn), addr, sizeof(addr));
    printk("Security changed for %s to level %d (err %d)\n", addr, level, err);

    if (err) {
        printk("Failed to change security for %s (err %d)\n", addr, err);
        return;
    } 

    k_sem_give(&semaphores.security);
}

#if BUILD_INITIATOR && CONFIG_BT_CHANNEL_SOUNDING
void dm_completed(struct bt_gatt_dm *dm, void *context) {
    int err;

    printk("The discovery procedure succeeded\n");

    struct bt_conn *conn = bt_gatt_dm_conn_get(dm);

    bt_gatt_dm_data_print(dm);

    /* Subscribing to SYNC_SERIVICE */
    if (context != NULL) {
        static struct bt_uuid_128 sync_id_uuid_inst = BT_UUID_INIT_128(SYNC_ID_UUID_VAL);
        
        const struct bt_gatt_dm_attr *sync_id_chrc_attr = bt_gatt_dm_char_by_uuid(dm, &sync_id_uuid_inst.uuid);
        if (!sync_id_chrc_attr) {
            printk("SYNC_ID_UUID characteristic not found!\n");
            bt_conn_disconnect(conn, BT_HCI_ERR_REMOTE_USER_TERM_CONN);
            goto release_dm_data;
        }
        indicate_ctx.char_handle = sync_id_chrc_attr->handle + 1;

        const struct bt_gatt_dm_attr *sync_id_ccc_attr = bt_gatt_dm_desc_by_uuid(dm, sync_id_chrc_attr, BT_UUID_GATT_CCC);
        if (!sync_id_ccc_attr) {
            printk("CCCD for SYNC_ID_UUID not found!\n");
            bt_conn_disconnect(conn, BT_HCI_ERR_REMOTE_USER_TERM_CONN);
            goto release_dm_data;
        }
        indicate_ctx.ccc_handle = sync_id_ccc_attr->handle;
        
        // Set up subscription parameters
        indicate_ctx.sub_params.ccc_handle = indicate_ctx.ccc_handle;
        indicate_ctx.sub_params.value_handle = indicate_ctx.char_handle;
        indicate_ctx.sub_params.value = BT_GATT_CCC_INDICATE;
        indicate_ctx.sub_params.notify = sync_id_indicated;
        indicate_ctx.sub_params.subscribe = NULL; 

        err = bt_gatt_subscribe(conn, &indicate_ctx.sub_params);
        if (err && err != -EALREADY) {
            printk("Failed to subscribe to SYNC_ID_UUID (err %d)\n", err);
            bt_conn_disconnect(conn, BT_HCI_ERR_REMOTE_USER_TERM_CONN);
            goto release_dm_data;
        }

        printk("Successfully subscribed to SYNC_ID indications\n");

    } else {
        // This is the ranging service discovery
        TRY(bt_ras_rreq_alloc_and_assign_handles(dm, conn));
    } 

release_dm_data:
    bt_gatt_dm_data_release(dm);
    k_sem_give(&semaphores.discovery);
}


void dm_service_not_found(struct bt_conn *conn, void *context) {
    printk("The service could not be found during the discovery, disconnecting\n");
    bt_conn_disconnect(ble_info.connection, BT_HCI_ERR_REMOTE_USER_TERM_CONN);
}

void dm_error_found(struct bt_conn *conn, int err, void *context) {
    printk("The discovery procedure failed (err %d)\n", err);
    bt_conn_disconnect(ble_info.connection, BT_HCI_ERR_REMOTE_USER_TERM_CONN);
}

void mtu_exchange_cb(struct bt_conn *conn, uint8_t err,
			    struct bt_gatt_exchange_params *params) {
	if (err) {
		printk("MTU exchange failed (err %d)\n", err);
		return;
	}

	printk("MTU exchange success (%u)\n", bt_gatt_get_mtu(conn));
    k_sem_give(&semaphores.mtu_exchange);
}
#endif 

void phy_changed_cb(struct bt_conn *conn, struct bt_conn_le_phy_info *param) {
    switch (param->tx_phy) {
        case BT_CONN_LE_TX_POWER_PHY_1M: 
            printk("Phy updated to 1M\n");
            break; 
        
        case BT_CONN_LE_TX_POWER_PHY_2M: 
            printk("Phy updated to 2M\n");
            break; 

        default: break; 
    }
}

/**********************************************************************/
/*                        SERVER / CLIENT                             */
/**********************************************************************/

BT_GATT_SERVICE_DEFINE(ble_sync_service,
    BT_GATT_PRIMARY_SERVICE(SYNC_SERVICE_UUID),
    BT_GATT_CHARACTERISTIC(SYNC_ID_UUID, 
        BT_GATT_CHRC_WRITE | BT_GATT_CHRC_INDICATE, 
        BT_GATT_PERM_WRITE_ENCRYPT, 
        NULL, sync_write_id, NULL),
    BT_GATT_CCC(sync_ccc_changed, BT_GATT_PERM_READ_ENCRYPT | BT_GATT_PERM_WRITE_ENCRYPT)
);

enum ble_state_ctx ble_get_currrent_state() {
    return ble_state.state; 
}

#if BUILD_INITIATOR 
int ble_write(bool state) {
    static struct bt_gatt_write_params write_params_led;
    struct bt_conn *c = ble_info.connection; 
    if (!c) {
        printk("LED write skipped â€“ not connected\n");
        sys_reboot(SYS_REBOOT_COLD);
        return -ENOTCONN;
    }

    if (indicate_ctx.char_handle == 0x0000) {
        printk("Invalid characteristic handle. Discovery might have failed.\n");
        return -EINVAL;
    }

    static uint8_t state_val; 
    state_val = state ? 0x01 : 0x00;

    write_params_led.func = sync_write_cb; 
    write_params_led.handle = indicate_ctx.char_handle;
    write_params_led.offset = 0;
    write_params_led.data = &state_val;
    write_params_led.length = sizeof(state_val);

    return bt_gatt_write(c, &write_params_led);
}
#endif 

#if BUILD_REFLECTOR 
void indicate_done(struct bt_conn *conn,
					struct bt_gatt_indicate_params *params,
					uint8_t err) {

    ARG_UNUSED(conn);
    ARG_UNUSED(err);
    ARG_UNUSED(params);
    indication_busy = false; 
}
#endif 

ssize_t sync_write_id(struct bt_conn *conn, const struct bt_gatt_attr *attr, 
	const void *buf, uint16_t len, uint16_t offset, uint8_t flags) {

    if(len != 1U || offset != 0) {
        printk("Illegal length or offset on SYNC_ID write.\n");
        return BT_GATT_ERR(BT_ATT_ERR_INVALID_ATTRIBUTE_LEN);
    }

    uint8_t val = *((uint8_t *)buf); 

    if(val != 0x00 && val != 0x01) {  // Fix the printk error
        printk("Incorrect write value: %d \n", val); 
        return BT_GATT_ERR(BT_ATT_ERR_VALUE_NOT_ALLOWED); 
    }

    sync_update_led(val ? true : false); 

    #if BUILD_REFLECTOR
    static uint8_t indicate_value;
    indicate_value = val;

    if (ble_info.conn_count)
        turn_idx %= ble_info.conn_count;
    
    // if (conn != ble_info.connections[turn_idx] ||
    //     ble_info.conn_count != CONFIG_BT_MAX_CONN) {
    //     return BT_GATT_ERR(BT_ATT_ERR_PREPARE_QUEUE_FULL);
    // }
    if (conn != ble_info.connections[turn_idx]) {
        return BT_GATT_ERR(BT_ATT_ERR_PREPARE_QUEUE_FULL);
    }

    if (indicate_value == 0x01) {
        
        if (active_conn && active_conn != conn) {
            return BT_GATT_ERR(BT_ATT_ERR_PREPARE_QUEUE_FULL);
        }
        if (indication_busy) {
            return BT_GATT_ERR(BT_ATT_ERR_PREPARE_QUEUE_FULL);
        }

        active_conn = conn;
        FIFO_CONTAINER_DEFINE(
            c, configure_cs_connection, ble_indicate_write, conn, indicate_value
        );
        if (!c) { 
            printk("CONTAINER WAS NULL :( \n"); 
            return BT_GATT_ERR(BT_ATT_ERR_PREPARE_QUEUE_FULL); }
        sync_put_fifo(c);
    }

    if (indicate_value == 0x00) {
        if (conn != active_conn) {
            return BT_GATT_ERR(BT_ATT_ERR_PREPARE_QUEUE_FULL);
        }
        
        active_conn = NULL; 
        turn_idx = (turn_idx + 1) % ble_info.conn_count; 
        FIFO_CONTAINER_DEFINE(
            c, configure_cs_connection, ble_indicate_write, conn, indicate_value
        );
        if (!c) { 
            printk("CONTAINER WAS NULL :( \n"); 
            return BT_GATT_ERR(BT_ATT_ERR_PREPARE_QUEUE_FULL); }
        sync_put_fifo(c); 
    }
    #endif

    return len;
}

#if BUILD_REFLECTOR 
void ble_indicate_write(struct bt_conn *conn, uint8_t val) {
    indication_busy = true; 

    static uint8_t p_val;
    p_val = val;  
    static struct bt_gatt_indicate_params p = {
        .attr = &ble_sync_service.attrs[1],
        .data = &p_val,
        .len = sizeof(p_val),
        .func = indicate_done,
    };
    
    int ret = bt_gatt_indicate(conn, &p); 

    if (ret) {
        printk("Failed to send LED state indication to connection %d (err %d)\n", 
            bt_conn_index(conn), ret);
        indication_busy = false;
    } else {
        printk("Wrote to conn %d state: %d\n", bt_conn_index(conn), p_val); 
    }
}
#endif 

/**********************************************************************/
/*                             GENERAL                                */
/**********************************************************************/

struct bt_conn *ble_init() {
    ble_setup_struct_and_types(); 
    cs_setup_struct_and_types();

    dk_leds_init();

    TRY(bt_enable(NULL)); 

    #if BUILD_INITIATOR 
        TRY(ble_adv_start());

        printk("Initator started, advertising as %s\n", INITIATOR_NAME);

        ble_update_state(ACTIVE_ADV); 

        k_sem_take(&semaphores.connected, K_FOREVER); // wait for connection

        TRY(bt_conn_set_security(ble_info.connection, BT_SECURITY_L2));

        k_sem_take(&semaphores.security, K_FOREVER); // wait for security to be established

        bt_gatt_exchange_mtu(ble_info.connection, &mtu_exchange_params);

        k_sem_take(&semaphores.mtu_exchange, K_FOREVER); // wait for maximum transition unit (MTU) exchange

        TRY(bt_gatt_dm_start(ble_info.connection, BT_UUID_RANGING_SERVICE, &gatt_callbacks, NULL));
        
        k_sem_take(&semaphores.discovery, K_FOREVER);
        
        TRY(bt_gatt_dm_start(ble_info.connection, SYNC_SERVICE_UUID, &gatt_callbacks, &indicate_ctx.char_handle));

        k_sem_take(&semaphores.discovery, K_FOREVER);
   
        printk("GATT discovery started successfully\n");

        return ble_info.connection; 
    #endif 

    #if BUILD_REFLECTOR
        TRY(ble_scan_init()); 
        
        TRY(bt_scan_start(BT_SCAN_TYPE_SCAN_ACTIVE));

        ble_update_state(ACTIVE_ADV); 

        return NULL; 
    #endif 
}

void ble_update_state(enum ble_state_ctx state) {
    k_mutex_lock(&ble_state.mutex, K_FOREVER); 
    ble_state.state = state; 
    k_mutex_unlock(&ble_state.mutex); 
}

#if BUILD_REFLECTOR 
int ble_scan_init() {
    bt_scan_init(&scan_param);
    TRY(bt_scan_filter_add(BT_SCAN_FILTER_TYPE_NAME, INITIATOR_NAME));
    TRY(bt_scan_filter_enable(BT_SCAN_NAME_FILTER, true));
    printk("BLE init done, scanning for %s\n", INITIATOR_NAME);
    return 0;
}
#endif 

int ble_setup_struct_and_types() {
    k_sem_init(&semaphores.connected, 0, 1); 
    k_sem_init(&semaphores.security, 0, 1); 

    #if BUILD_REFLECTOR 
    memset(ble_info.connections, 0, sizeof(ble_info.connections)); 
    ble_info.conn_count = 0; 
    #endif 

    #if BUILD_INITIATOR 
    ble_info.connection = NULL; 
    k_sem_init(&semaphores.mtu_exchange, 0, 1); 
    k_sem_init(&semaphores.discovery, 0, 1); 
    #endif 

    k_mutex_init(&ble_state.mutex);
    ble_state.state = SETUP; 

    return 0; 
}

void ble_set_phy(struct bt_conn *conn) {
    const struct bt_conn_le_phy_param phy = {
       .options = BT_CONN_LE_PHY_OPT_NONE,
       .pref_tx_phy = BT_GAP_LE_PHY_2M, 
       .pref_rx_phy = BT_GAP_LE_PHY_2M,
    };

    TRY(bt_conn_le_phy_update(conn, &phy)); 
}

#if BUILD_INITIATOR 
int ble_adv_start() {
    return bt_le_adv_start(BT_LE_ADV_CONN_FAST_2, adv, ARRAY_SIZE(adv), scan_rsp, ARRAY_SIZE(scan_rsp)); 
}

#endif

================
File: lib\ble\ble.h
================
#pragma once

#include "../global.h"
#include <cs.h>
#include <sync.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/uuid.h>
#include <zephyr/sys/reboot.h>
#include <dk_buttons_and_leds.h>

#if BUILD_REFLECTOR 
#include <bluetooth/scan.h>
#endif 

#include <zephyr/bluetooth/gap.h>
#include <zephyr/types.h>

struct bt_conn *ble_init(); 
int ble_scan_init();
int ble_adv_start(); 
void ble_set_phy(struct bt_conn *conn); 
void ble_connections_handler(); 
int ble_write(bool led_state); 


/**********************************************************************/
/*                       STRUCTURES AND TYPES                         */
/**********************************************************************/

/** @brief  Contains the context of the device bluetooth state */
enum ble_state_ctx {
    SETUP, 
    ACTIVE_ADV, 
    ACTIVE_SCAN, 
    INACTIVE_ADV, 
    INACTIVE_SCAN, 
};

struct ble_state_handler {
    enum ble_state_ctx state; 
    struct k_mutex mutex; 
}; 

/** @brief Contains the context of bluetooth connection"s" */
struct ble_ctx {
    #if BUILD_REFLECTOR
    struct bt_conn *connections[CONFIG_BT_MAX_CONN]; 
    uint8_t conn_count; 
    #endif 

    #if BUILD_INITIATOR 
    struct bt_conn *connection; 
    #endif 
};

/** @brief Contains the context of semaphores used for bluetooth stack */
struct semaphores_ctx {
    struct k_sem connected; 
    struct k_sem security; 

    #if BUILD_INITIATOR 
    struct k_sem mtu_exchange; 
    struct k_sem discovery; 
    #endif 
}; 

/** @brief Contians info about gatt writting and indication */
struct indicate_handler {
    struct bt_gatt_write_params write_led_param; 
    struct bt_gatt_subscribe_params sub_params; 
    uint16_t char_handle; 
    uint16_t ccc_handle; 
}; 


int ble_setup_struct_and_types(); 
void ble_update_state(enum ble_state_ctx state); 
enum ble_state_ctx ble_get_currrent_state(); 

/**********************************************************************/
/*                 NOTIFICATION / SYNCHRONIZATION                     */
/**********************************************************************/

/** @brief Service UUID for ble synchronization */ 
#define SYNC_SERVICE_UUID_VAL \
    BT_UUID_128_ENCODE(0xca03b72e, 0xd5dd, 0x438e, 0xbda5, 0x2d4e8780d565)

#define SYNC_SERVICE_UUID BT_UUID_DECLARE_128(SYNC_SERVICE_UUID_VAL)

/** @brief ID of initiator */ 
#define SYNC_ID_UUID_VAL \
    BT_UUID_128_ENCODE(0x6159b793, 0x24a3, 0x4402, 0xbd84, 0xd6375a4ce9b5)

#define SYNC_ID_UUID BT_UUID_DECLARE_128(SYNC_ID_UUID_VAL)

void indicate_done(struct bt_conn *conn,
					struct bt_gatt_indicate_params *params,
					uint8_t err); 

#if BUILD_REFLECTOR 
void ble_indicate_write(struct bt_conn *conn, uint8_t val); 
#endif 
    
/**********************************************************************/
/*                           CALLBACKS                                */
/**********************************************************************/

void connected(struct bt_conn *conn, uint8_t err);
void disconnected(struct bt_conn *conn, uint8_t reason);
void security_changed(struct bt_conn *conn, bt_security_t level, enum bt_security_err err);
void dm_completed(struct bt_gatt_dm *dm, void *context);
void dm_service_not_found(struct bt_conn *conn, void *context);
void dm_error_found(struct bt_conn *conn, int err, void *context);
void mtu_exchange_cb(struct bt_conn *conn, uint8_t err, struct bt_gatt_exchange_params *params);
void phy_changed_cb(struct bt_conn *conn, struct bt_conn_le_phy_info *param);

================
File: lib\calc\calc.c
================
#include "calc.h"

static K_MUTEX_DEFINE(distance_estimate_buffer_mutex);

static uint8_t buffer_index;
static uint8_t buffer_num_valid;
static cs_de_dist_estimates_t distance_estimate_buffer[MAX_AP][DE_SLIDING_WINDOW_SIZE];

uint8_t cs_buffer_status() {
	return buffer_num_valid; 
}

cs_de_dist_estimates_t get_distance(uint8_t ap) {
	cs_de_dist_estimates_t averaged_result = {};
	uint8_t num_ifft = 0;
	uint8_t num_phase_slope = 0;
	uint8_t num_rtt = 0;

	int lock_state = k_mutex_lock(&distance_estimate_buffer_mutex, K_FOREVER);

	__ASSERT_NO_MSG(lock_state == 0);

	for (uint8_t i = 0; i < buffer_num_valid; i++) {
		if (isfinite(distance_estimate_buffer[ap][i].ifft)) { // isfinite i.e is a real number check 
			num_ifft++;
			averaged_result.ifft += distance_estimate_buffer[ap][i].ifft;
		}
		if (isfinite(distance_estimate_buffer[ap][i].phase_slope)) {
			num_phase_slope++;
			averaged_result.phase_slope += distance_estimate_buffer[ap][i].phase_slope;
		}
		if (isfinite(distance_estimate_buffer[ap][i].rtt)) {
			num_rtt++;
			averaged_result.rtt += distance_estimate_buffer[ap][i].rtt;
		}
	}

	k_mutex_unlock(&distance_estimate_buffer_mutex);

	if (num_ifft) {
		averaged_result.ifft /= num_ifft;
	}

	if (num_phase_slope) {
		averaged_result.phase_slope /= num_phase_slope;
	}

	if (num_rtt) {
		averaged_result.rtt /= num_rtt;
	}

	return averaged_result;
}

void store_distance_estimates(cs_de_report_t *p_report) {
	int lock_state = k_mutex_lock(&distance_estimate_buffer_mutex, K_FOREVER);

	__ASSERT_NO_MSG(lock_state == 0);

	for (uint8_t ap = 0; ap < p_report->n_ap; ap++) {
		memcpy(&distance_estimate_buffer[ap][buffer_index],
		       &p_report->distance_estimates[ap], sizeof(cs_de_dist_estimates_t));
	}

	buffer_index = (buffer_index + 1) % DE_SLIDING_WINDOW_SIZE;

	if (buffer_num_valid < DE_SLIDING_WINDOW_SIZE) {
		buffer_num_valid++;
	}

	k_mutex_unlock(&distance_estimate_buffer_mutex);
}

================
File: lib\calc\calc.h
================
#pragma once

#include <zephyr/kernel.h>
#include <math.h>
#include <zephyr/bluetooth/cs.h>
#include <bluetooth/services/ras.h>
#include <bluetooth/cs_de.h>
#include "../global.h"

void store_distance_estimates(cs_de_report_t *p_report);
uint8_t cs_buffer_status();
cs_de_dist_estimates_t get_distance(uint8_t ap);

================
File: lib\calc_black_box\calc_black_box.c
================
#include "calc_black_box.h"

static void calc_complex_product(int32_t z_a_real, int32_t z_a_imag, int32_t z_b_real,
				 int32_t z_b_imag, int32_t *z_out_real, int32_t *z_out_imag)
{
	*z_out_real = z_a_real * z_b_real - z_a_imag * z_b_imag;
	*z_out_imag = z_a_real * z_b_imag + z_a_imag * z_b_real;
}

static struct iq_sample_and_channel_replica iq_sample_channel_data[MAX_NUM_IQ_SAMPLES];
static struct rtt_timing rtt_timing_data[MAX_NUM_RTT_SAMPLES];

static float linear_regression(float *x_values, float *y_values, uint8_t n_samples)
{
	if (n_samples == 0) {
		return 0.0;
	}

	/* Estimates b in y = a + b x */

	float y_mean = 0.0;
	float x_mean = 0.0;

	for (uint8_t i = 0; i < n_samples; i++) {
		y_mean += (y_values[i] - y_mean) / (i + 1);
		x_mean += (x_values[i] - x_mean) / (i + 1);
	}

	float b_est_upper = 0.0;
	float b_est_lower = 0.0;

	for (uint8_t i = 0; i < n_samples; i++) {
		b_est_upper += (x_values[i] - x_mean) * (y_values[i] - y_mean);
		b_est_lower += (x_values[i] - x_mean) * (x_values[i] - x_mean);
	}

	return b_est_upper / b_est_lower;
}

static void bubblesort_2(float *array1, float *array2, uint16_t len)
{
	bool swapped;
	float temp;

	for (uint16_t i = 0; i < len - 1; i++) {
		swapped = false;
		for (uint16_t j = 0; j < len - i - 1; j++) {
			if (array1[j] > array1[j + 1]) {
				temp = array1[j];
				array1[j] = array1[j + 1];
				array1[j + 1] = temp;
				temp = array2[j];
				array2[j] = array2[j + 1];
				array2[j + 1] = temp;
				swapped = true;
			}
		}

		if (!swapped) {
			break;
		}
	}
}

static float estimate_distance_using_phase_slope(struct iq_sample_and_channel *data,
						 uint8_t len,
						 uint8_t ant_path,
						 uint8_t *samples_cnt)
{
	int32_t combined_i;
	int32_t combined_q;
	uint16_t num_angles = 0;
	static float theta[MAX_NUM_IQ_SAMPLES];
	static float frequencies[MAX_NUM_IQ_SAMPLES];

	for (uint8_t i = 0; i < len; i++) {
		if (!data[i].failed && data[i].antenna_path == ant_path) {
			calc_complex_product(data[i].local_iq_sample.i, data[i].local_iq_sample.q,
					     data[i].peer_iq_sample.i, data[i].peer_iq_sample.q,
					     &combined_i, &combined_q);

			theta[num_angles] = atan2(1.0 * combined_q, 1.0 * combined_i);
			frequencies[num_angles] = 1.0 * CS_FREQUENCY_MHZ(data[i].channel);
			num_angles++;
			*samples_cnt += 1;
		}
	}

	if (num_angles < 2) {
		return 0.0;
	}

	/* Sort phases by tone frequency */
	bubblesort_2(frequencies, theta, num_angles);

	/* One-dimensional phase unwrapping */
	for (uint8_t i = 1; i < num_angles; i++) {
		float difference = theta[i] - theta[i - 1];

		if (difference > PI) {
			for (uint8_t j = i; j < num_angles; j++) {
				theta[j] -= 2.0f * PI;
			}
		} else if (difference < -PI) {
			for (uint8_t j = i; j < num_angles; j++) {
				theta[j] += 2.0f * PI;
			}
		}
	}

	float phase_slope = linear_regression(frequencies, theta, num_angles);

	float distance = -phase_slope * (SPEED_OF_LIGHT_M_PER_S / (4 * PI));

	return distance / 1000000.0f; /* Scale to meters. */
}

static float estimate_distance_using_time_of_flight(uint8_t n_samples)
{
	float tof;
	float tof_mean = 0.0;

	/* Cumulative Moving Average */
	for (uint8_t i = 0; i < n_samples; i++) {
		if (!rtt_timing_data[i].failed) {
			tof = (rtt_timing_data[i].toa_tod_initiator -
			       rtt_timing_data[i].tod_toa_reflector) /
			      2;
			tof_mean += (tof - tof_mean) / (i + 1);
		}
	}

	float tof_mean_ns = tof_mean / 2.0f;

	return tof_mean_ns * SPEED_OF_LIGHT_NM_PER_S;
}

static void process_tone_info_data(struct processing_context *context,
			      struct bt_hci_le_cs_step_data_tone_info local_tone_info[],
			      struct bt_hci_le_cs_step_data_tone_info peer_tone_info[],
			      uint8_t channel, uint8_t antenna_permutation_index)
{
	struct bt_le_cs_iq_sample step_iq_sample;
	struct bt_le_cs_iq_sample peert_tep_iq_sample;
	for (uint8_t i = 0; i < (context->n_ap + 1); i++) {
		if (local_tone_info[i].extension_indicator != BT_HCI_LE_CS_NOT_TONE_EXT_SLOT ||
		    peer_tone_info[i].extension_indicator != BT_HCI_LE_CS_NOT_TONE_EXT_SLOT) {
			continue;
		}

		if (context->iq_sample_channel_data_index >= MAX_NUM_IQ_SAMPLES) {
			printk("More IQ samples than size of iq_sample_channel_data array\n");
			return;
		}

		int antenna_path = bt_le_cs_get_antenna_path(context->n_ap,
							     antenna_permutation_index,
							     i);
		if (antenna_path < 0) {
			printk("Invalid antenna path\n");
			return;
		}

		iq_sample_channel_data[context->iq_sample_channel_data_index].channel = channel;
		iq_sample_channel_data[context->iq_sample_channel_data_index].antenna_path =
			(uint8_t)antenna_path;
		step_iq_sample=bt_le_cs_parse_pct(local_tone_info[i].phase_correction_term);
		iq_sample_channel_data[context->iq_sample_channel_data_index].local_iq_sample.i=step_iq_sample.i;
		iq_sample_channel_data[context->iq_sample_channel_data_index].local_iq_sample.q=step_iq_sample.q;
		peert_tep_iq_sample=bt_le_cs_parse_pct(peer_tone_info[i].phase_correction_term);
		iq_sample_channel_data[context->iq_sample_channel_data_index].peer_iq_sample.i=peert_tep_iq_sample.i;
		iq_sample_channel_data[context->iq_sample_channel_data_index].peer_iq_sample.q=peert_tep_iq_sample.q;
		/*	
		iq_sample_channel_data[context->iq_sample_channel_data_index].local_iq_sample =
			bt_le_cs_parse_pct(local_tone_info[i].phase_correction_term);
		iq_sample_channel_data[context->iq_sample_channel_data_index].peer_iq_sample =
			bt_le_cs_parse_pct(peer_tone_info[i].phase_correction_term);
		*/
		if (local_tone_info[i].quality_indicator == BT_HCI_LE_CS_TONE_QUALITY_LOW ||
		    local_tone_info[i].quality_indicator == BT_HCI_LE_CS_TONE_QUALITY_UNAVAILABLE ||
			local_tone_info[i].quality_indicator == BT_HCI_LE_CS_TONE_QUALITY_MED ||
		    peer_tone_info[i].quality_indicator == BT_HCI_LE_CS_TONE_QUALITY_LOW ||
		    peer_tone_info[i].quality_indicator == BT_HCI_LE_CS_TONE_QUALITY_UNAVAILABLE || 
			peer_tone_info[i].quality_indicator == BT_HCI_LE_CS_TONE_QUALITY_MED) {
			iq_sample_channel_data[context->iq_sample_channel_data_index].failed = true;
		}

		context->iq_sample_channel_data_index++;
	}
}

static void process_rtt_timing_data(struct processing_context *context,
			       struct bt_hci_le_cs_step_data_mode_1 *local_rtt_data,
			       struct bt_hci_le_cs_step_data_mode_1 *peer_rtt_data)
{
	if (context->rtt_timing_data_index >= MAX_NUM_RTT_SAMPLES) {
		printk("More RTT samples processed than size of rtt_timing_data array\n");
		return;
	}

	if (local_rtt_data->packet_quality_aa_check !=
		    BT_HCI_LE_CS_PACKET_QUALITY_AA_CHECK_SUCCESSFUL ||
	    local_rtt_data->packet_rssi == BT_HCI_LE_CS_PACKET_RSSI_NOT_AVAILABLE ||
	    local_rtt_data->tod_toa_reflector == BT_HCI_LE_CS_TIME_DIFFERENCE_NOT_AVAILABLE ||
	    peer_rtt_data->packet_quality_aa_check !=
		    BT_HCI_LE_CS_PACKET_QUALITY_AA_CHECK_SUCCESSFUL ||
	    peer_rtt_data->packet_rssi == BT_HCI_LE_CS_PACKET_RSSI_NOT_AVAILABLE ||
	    peer_rtt_data->tod_toa_reflector == BT_HCI_LE_CS_TIME_DIFFERENCE_NOT_AVAILABLE) {
		rtt_timing_data[context->rtt_timing_data_index].failed = true;
	}

	if (context->role == BT_CONN_LE_CS_ROLE_INITIATOR) {
		rtt_timing_data[context->rtt_timing_data_index].toa_tod_initiator =
			local_rtt_data->toa_tod_initiator;
		rtt_timing_data[context->rtt_timing_data_index].tod_toa_reflector =
			peer_rtt_data->tod_toa_reflector;
	} else if (context->role == BT_CONN_LE_CS_ROLE_REFLECTOR) {
		rtt_timing_data[context->rtt_timing_data_index].tod_toa_reflector =
			local_rtt_data->tod_toa_reflector;
		rtt_timing_data[context->rtt_timing_data_index].toa_tod_initiator =
			peer_rtt_data->toa_tod_initiator;
	}

	context->rtt_timing_data_index++;
}

static bool process_step_data(struct bt_le_cs_subevent_step *local_step,
			      struct bt_le_cs_subevent_step *peer_step, void *user_data)
{
	struct processing_context *context = (struct processing_context *)user_data;

	if (local_step->mode == BT_CONN_LE_CS_MAIN_MODE_2) {
		struct bt_hci_le_cs_step_data_mode_2 *local_step_data =
			(struct bt_hci_le_cs_step_data_mode_2 *)local_step->data;
		struct bt_hci_le_cs_step_data_mode_2 *peer_step_data =
			(struct bt_hci_le_cs_step_data_mode_2 *)peer_step->data;

		process_tone_info_data(context, local_step_data->tone_info,
				       peer_step_data->tone_info, local_step->channel,
				       local_step_data->antenna_permutation_index);

	} else if (local_step->mode == BT_HCI_OP_LE_CS_MAIN_MODE_1) {
		struct bt_hci_le_cs_step_data_mode_1 *local_step_data =
			(struct bt_hci_le_cs_step_data_mode_1 *)local_step->data;
		struct bt_hci_le_cs_step_data_mode_1 *peer_step_data =
			(struct bt_hci_le_cs_step_data_mode_1 *)peer_step->data;

		//process_rtt_timing_data(context, local_step_data, peer_step_data);

	} else if (local_step->mode == BT_HCI_OP_LE_CS_MAIN_MODE_3) {
		struct bt_hci_le_cs_step_data_mode_3 *local_step_data =
			(struct bt_hci_le_cs_step_data_mode_3 *)local_step->data;
		struct bt_hci_le_cs_step_data_mode_3 *peer_step_data =
			(struct bt_hci_le_cs_step_data_mode_3 *)peer_step->data;
		/*
		process_rtt_timing_data(context,
					(struct bt_hci_le_cs_step_data_mode_1 *)local_step_data,
					(struct bt_hci_le_cs_step_data_mode_1 *)peer_step_data);
		*/
		process_tone_info_data(context, local_step_data->tone_info,
				       peer_step_data->tone_info, local_step->channel,
				       local_step_data->antenna_permutation_index);
	}

	return true;
}
//add by david duan
static bool process_ranging_header(struct ras_ranging_header *ranging_header, void *user_data)
{
	cs_de_report_t *p_report = (cs_de_report_t *)user_data;

	p_report->n_ap = ((ranging_header->antenna_paths_mask & BIT(0)) +
			  ((ranging_header->antenna_paths_mask & BIT(1)) >> 1) +
			  ((ranging_header->antenna_paths_mask & BIT(2)) >> 2) +
			  ((ranging_header->antenna_paths_mask & BIT(3)) >> 3));
	return true;
}

float estimate_distance(struct net_buf_simple *local_steps, struct net_buf_simple *peer_steps,
		       uint8_t n_ap, enum bt_conn_le_cs_role role, uint16_t latest_compensation)
{
	bool distance_measurement_failed = true;
	struct processing_context context = {
		.rtt_timing_data_index = 0,
		.iq_sample_channel_data_index = 0,
		.n_ap = n_ap,
		.role = role,
	};

	memset(rtt_timing_data, 0, sizeof(rtt_timing_data));
	memset(iq_sample_channel_data, 0, sizeof(iq_sample_channel_data));

	bt_ras_rreq_rd_subevent_data_parse(peer_steps, local_steps, context.role,process_ranging_header, NULL,
					   process_step_data, &context);

	// printk("Estimated distance to reflector:\n");
/*
	float rtt_based_distance =
		estimate_distance_using_time_of_flight(context.rtt_timing_data_index);

	if (rtt_based_distance != 0.0f) {
		printk("- Round-Trip Timing method: %f meters (derived from %d samples)\n",
			(double)rtt_based_distance, context.rtt_timing_data_index);
		distance_measurement_failed = false;
	}
*/
	for (int i = 0; i < n_ap; i++) {
		uint8_t samples_cnt = 0;

		// float phase_slope_based_distance_2 = estimate_distance_using_phase_slope(
		// 	iq_sample_channel_data,
		// 	context.iq_sample_channel_data_index,
		// 	i,
		// 	&samples_cnt);
		// for coreaiot_distance

		float phase_slope_based_distance = 0.0f; 
		// if (samples_cnt != 0) {
			phase_slope_based_distance =  estimate_distance_coreaiot(
				(struct iq_sample_and_channel_replica *)iq_sample_channel_data,
				context.iq_sample_channel_data_index, i, &samples_cnt, latest_compensation,0);
		// }
		
		if (phase_slope_based_distance != 0.0f) {
			printk("DIST:%.3f,AP:%d,SAMPLES:%d\n", (double)phase_slope_based_distance, n_ap, samples_cnt); 

			distance_measurement_failed = false;
			return phase_slope_based_distance; 
		}
	}
	if (distance_measurement_failed) {
		// printk("- A reliable distance estimate could not be computed.\n");
		return 0.0f;
	}

	return 0.0f;
}

================
File: lib\calc_black_box\calc_black_box.h
================
#pragma once 

#include <stdint.h>
#include <zephyr/bluetooth/cs.h>
#include "zephyr/bluetooth/hci_types.h"
#include <math.h>
#include <zephyr/bluetooth/cs.h>
#include <bluetooth/services/ras.h>
#include "coreaiot_distance.h"
#include <bluetooth/cs_de.h>
#include <zephyr/drivers/uart.h>
#include "../global.h"

#define CS_FREQUENCY_MHZ(ch)	(2402u + 1u * (ch))
#define CS_FREQUENCY_HZ(ch)	(CS_FREQUENCY_MHZ(ch) * 1000000.0f)
#define SPEED_OF_LIGHT_M_PER_S	(299792458.0f)
#define SPEED_OF_LIGHT_NM_PER_S (SPEED_OF_LIGHT_M_PER_S / 1000000000.0f)
#define PI			3.14159265358979323846f
#define MAX_NUM_RTT_SAMPLES		256
#define MAX_NUM_IQ_SAMPLES		256 * CONFIG_BT_RAS_MAX_ANTENNA_PATHS
#define STRIDE 4 
#define CS_BANDWIDTH_HZ 80000000.0f  // 80 MHz for Bluetooth Channel Sounding
#define IFFT_SIZE 64
#define MAX_DISTANCE_BINS (IFFT_SIZE / 2)

struct iq_sample_and_channel {
	bool failed;
	uint8_t channel;
	uint8_t antenna_path;
	struct bt_le_cs_iq_sample local_iq_sample;
	struct bt_le_cs_iq_sample peer_iq_sample;
};

struct rtt_timing {
	bool failed;
	int16_t toa_tod_initiator;
	int16_t tod_toa_reflector;
};

struct processing_context {
	uint16_t rtt_timing_data_index;
	uint16_t iq_sample_channel_data_index;
	uint8_t n_ap;
	enum bt_conn_le_cs_role role;
};

struct complex_sample {
    float real;
    float imag;
};

float estimate_distance(struct net_buf_simple *local_steps, struct net_buf_simple *peer_steps,
		       uint8_t n_ap, enum bt_conn_le_cs_role role,uint16_t compensation);

================
File: lib\cs\cs.c
================
#include "cs.h"

#if BUILD_INITIATOR 
struct cs_semaphores_ctx sem_cs; 
struct cs_count_ctx counter; 

static struct bt_le_cs_create_config_params config_params = {
    .id = ID,
    .main_mode_type = BT_CONN_LE_CS_MAIN_MODE_2, 
    .sub_mode_type = BT_CONN_LE_CS_SUB_MODE_1, 
    .min_main_mode_steps = 3, 
    .max_main_mode_steps = 9, 
    .main_mode_repetition = 0,
    .mode_0_steps = 1,
    .role = BT_CONN_LE_CS_ROLE_INITIATOR,
    .rtt_type =  BT_CONN_LE_CS_RTT_TYPE_AA_ONLY,
    .cs_sync_phy = BT_CONN_LE_CS_SYNC_2M_PHY,  
    .channel_map_repetition = 1,
    .channel_selection_type = BT_CONN_LE_CS_CHSEL_TYPE_3B,
    .ch3c_shape = BT_CONN_LE_CS_CH3C_SHAPE_HAT,
    .ch3c_jump = 2,
};

static const struct bt_le_cs_set_procedure_parameters_param procedure_params = {
	.config_id = ID,
	.max_procedure_len = 12,
	.min_procedure_interval = 2,
	.max_procedure_interval = 5, 
	.max_procedure_count = 1,
	.min_subevent_len = 2000,
	.max_subevent_len = 4000,
	.tone_antenna_config_selection = BT_LE_CS_TONE_ANTENNA_CONFIGURATION_A1_B1,
	.phy = BT_LE_CS_PROCEDURE_PHY_2M, 
	.tx_power_delta = 0x80,
	.preferred_peer_antenna = BT_LE_CS_PROCEDURE_PREFERRED_PEER_ANTENNA_1,
	.snr_control_initiator = BT_LE_CS_SNR_CONTROL_NOT_USED,
	.snr_control_reflector = BT_LE_CS_SNR_CONTROL_NOT_USED,
};

__aligned(4) NET_BUF_SIMPLE_DEFINE_STATIC(latest_local_steps, LOCAL_PROCEDURE_MEM);
__aligned(4) NET_BUF_SIMPLE_DEFINE_STATIC(latest_peer_steps, BT_RAS_PROCEDURE_MEM);
#endif 

#if BUILD_REFLECTOR 
struct cs_ctx ctx[CONFIG_BT_MAX_CONN]; 
#endif 

static const struct bt_le_cs_set_default_settings_param default_settings = {
	#if BUILD_INITIATOR
    .enable_initiator_role = true,
    .enable_reflector_role = false, 
	#else
	.enable_initiator_role = false,
	.enable_reflector_role = true,
	#endif 

    .cs_sync_antenna_selection = BT_LE_CS_ANTENNA_SELECTION_OPT_REPETITIVE,
    .max_tx_power = BT_HCI_OP_LE_CS_MAX_MAX_TX_POWER
};

/**********************************************************************/
/*                           CALLBACKS                                */
/**********************************************************************/

BT_CONN_CB_DEFINE(cs_callbacks) = {
	.le_cs_read_remote_capabilities_complete = remote_capabilities_cb,
	.le_cs_config_complete = config_create_cb,
	.le_cs_security_enable_complete = security_enable_cb,
	.le_cs_procedure_enable_complete = procedure_enable_cb,

	#if BUILD_INITIATOR 
	.le_cs_subevent_data_available = subevent_result_cb, 
	#endif 
};
 


void remote_capabilities_cb(struct bt_conn *conn, 
	uint8_t status, struct bt_conn_le_cs_capabilities *params) {
	
	#if BUILD_INITIATOR 
	ARG_UNUSED(conn); 
	#endif  
	ARG_UNUSED(params); 

    printk("[CS] caps-complete: status=0x%02x conn=%d\n", status, bt_conn_index(conn));
    if (status == BT_HCI_ERR_SUCCESS) {
		printk("CS capability exchange completed.\n");
		TRY(bt_le_cs_set_default_settings(conn, &default_settings));
	} else {
		printk("CS capability exchange failed. (HCI status 0x%02x)\n", status);
	}

	#if BUILD_INITIATOR 
	k_sem_give(&sem_cs.rrq_capabilites);
	#else 
	int idx = bt_conn_index(conn);
	bool is_valid_conn_index = (idx >= 0 && idx < CONFIG_BT_MAX_CONN);

	if (!is_valid_conn_index) {
		printk("Invalid index\n");
		return; 
	}
	k_sem_give(&ctx[bt_conn_index(conn)].sem_cs.rrq_capabilites); 
	#endif 
}

void security_enable_cb(struct bt_conn *conn, uint8_t status) {
	#if BUILD_INITIATOR 
	ARG_UNUSED(conn); 
	#endif  

    printk("[CS] security: %s conn=%d\n", status==BT_HCI_ERR_SUCCESS?"enabled":"FAIL", bt_conn_index(conn));
    if (status == BT_HCI_ERR_SUCCESS) {
		printk("CS security enabled.\n");

		#if BUILD_INITIATOR 
		k_sem_give(&sem_cs.cs_security);
		#else 
		k_sem_give(&ctx[bt_conn_index(conn)].sem_cs.cs_security); 
		#endif 

	} else {
		printk("CS security enable failed. (HCI status 0x%02x)\n", status);
	}
}

void config_create_cb(struct bt_conn *conn, uint8_t status, struct bt_conn_le_cs_config *config) {
	#if BUILD_INITIATOR 
	ARG_UNUSED(conn); 
	#endif  

    printk("[CS] config-complete: status=0x%02x id=%d conn=%d\n", status, config->id, bt_conn_index(conn));
    if (status == BT_HCI_ERR_SUCCESS) {
        printk("CS config creation complete. ID: %d\n", config->id);
		#if BUILD_INITIATOR 
		k_sem_give(&sem_cs.create_config);
		#else 
		TRY(bt_le_cs_security_enable(conn));
		k_sem_give(&ctx[bt_conn_index(conn)].sem_cs.create_config); 
		#endif 
	} else {
		printk("CS config creation failed. (HCI status 0x%02x)\n", status);
	}
}

void procedure_enable_cb(struct bt_conn *conn, uint8_t status, struct bt_conn_le_cs_procedure_enable_complete *params) {
	ARG_UNUSED(conn);

    printk("[CS] proc-enable: status=0x%02x state=%u conn=%d\n", status, params?params->state:255, bt_conn_index(conn));
    if (status != BT_HCI_ERR_SUCCESS) {
		printk("CS procedures enable failed. (HCI status 0x%02x)\n", status);

		#if BUILD_INITIATOR 
		k_sem_give(&sem_cs.procedure_done);
		#endif 
		return; 
	}

	if (params->state == 1) {
		#if BUILD_REFLECTOR 
		printk("CS procedures enabled conn %d.\n", bt_conn_index(conn)); 
		#endif  
	} else {
		printk("CS procedures disabled.\n");
		#if BUILD_INITIATOR 
		k_sem_give(&sem_cs.procedure_disabled); 
		k_sem_give(&sem_cs.procedure_done);
		#endif 
	}
}

#if BUILD_INITIATOR
void subevent_result_cb(struct bt_conn *conn, struct bt_conn_le_cs_subevent_result *result) {
	counter.latest_frequency_compensation = result->header.frequency_compensation;

	if (counter.dropped_ranging == result->header.procedure_counter) {
		return;
	}

	bool usable_subevent = 	
		result->header.subevent_done_status != BT_CONN_LE_CS_SUBEVENT_ABORTED; 
	

    printk("[CS][INIT] subevent: pc=%u done=%u sub_done=%u n_ap=%u step_len=%d\n",
           result->header.procedure_counter,
           result->header.procedure_done_status,
           result->header.subevent_done_status,
           result->header.num_antenna_paths,
           result->step_data_buf ? result->step_data_buf->len : -1);

    if (usable_subevent && result->step_data_buf) {
		if (result->step_data_buf->len <= net_buf_simple_tailroom(&latest_local_steps)) {
			uint16_t len = result->step_data_buf->len;
			uint8_t *step_data = net_buf_simple_pull_mem(result->step_data_buf, len);
			net_buf_simple_add_mem(&latest_local_steps, step_data, len);
            printk("[CS][INIT] buffered: local_steps=%d/%d\n", latest_local_steps.len, latest_local_steps.size);
		} else {
			printk("Not enough memory to store step data. (%d > %d)\n",
				latest_local_steps.len + result->step_data_buf->len,
				latest_local_steps.size);
			net_buf_simple_reset(&latest_local_steps);
			counter.dropped_ranging = result->header.procedure_counter;
			return;
		}
	}

	counter.dropped_ranging = PROCEDURE_COUNTER_NONE;
	counter.n_ap = result->header.num_antenna_paths; 

	if (result->header.procedure_done_status == BT_CONN_LE_CS_PROCEDURE_ABORTED) {
		printk("Procedure %u aborted\n", result->header.procedure_counter);
		net_buf_simple_reset(&latest_local_steps);
		k_sem_give(&sem_cs.procedure_done); 
		k_sem_give(&sem_cs.local_steps);
	}

	if (result->header.procedure_done_status == BT_HCI_LE_CS_PROCEDURE_DONE_STATUS_COMPLETE) {
		counter.most_recent_local_ranging = result->header.procedure_counter; 
		k_sem_give(&sem_cs.procedure_done); 
	}
}

void ranging_data_ready_cb(struct bt_conn *conn, uint16_t ranging_counter) {
    printk("[CS][INIT] RD ready: pc=%u conn=%d\n", ranging_counter, bt_conn_index(conn));
    counter.most_recent_peer_ranging = ranging_counter; 
	k_sem_give(&sem_cs.rd_ready); 
}

void ranging_data_get_complete_cb(struct bt_conn *conn, uint16_t ranging_counter, int err) {
	counter.ranging_data_err = err; 

	if (err) {
		printk("Error when getting ranging data with ranging counter %d (err %d)\n",
			ranging_counter, err);
	}

    if (!err) printk("[CS][INIT] RD complete: pc=%u len=%d\n", ranging_counter, latest_peer_steps.len);
	k_sem_give(&sem_cs.rd_complete); 
}

void ranging_data_overwritten_cb(struct bt_conn *conn, uint16_t ranging_counter) {
	printk("Ranging data overwritten %i\n", ranging_counter);
}
#endif 

/**********************************************************************/
/*                             GENERAL                                */
/**********************************************************************/

void cs_setup_struct_and_types() {
	#if BUILD_REFLECTOR 
	for (int i = 0; i < CONFIG_BT_MAX_CONN; i++) {
		memset(&ctx[i].counter, 0, sizeof(struct cs_count_ctx)); 
		k_sem_init(&ctx[i].sem_cs.cs_security, 0, 1); 
		k_sem_init(&ctx[i].sem_cs.rrq_capabilites, 0, 1); 
		k_sem_init(&ctx[i].sem_cs.create_config, 0, 1); 
	}
	#else 
	memset(&counter, 0, sizeof(struct cs_count_ctx)); 
	k_sem_init(&sem_cs.cs_security, 0, 1); 
	k_sem_init(&sem_cs.rrq_capabilites, 0, 1); 
	k_sem_init(&sem_cs.create_config, 0, 1); 
	k_sem_init(&sem_cs.local_steps, 0, 1); 
	k_sem_init(&sem_cs.procedure_disabled, 0, 1); 
	k_sem_init(&sem_cs.rd_complete, 0, 1); 
	k_sem_init(&sem_cs.rd_ready, 0, 1); 
	k_sem_init(&sem_cs.procedure_done, 0, 1); 
	#endif 
}

#if BUILD_REFLECTOR
void cs_reset_state(struct bt_conn *conn) {
    if (!conn) {
        printk("Error: NULL connection in cs_reset_state\n");
        return;
    }
    
    int idx = bt_conn_index(conn);
    if (idx < 0 || idx >= CONFIG_BT_MAX_CONN) {
        printk("Error: Invalid connection index %d in cs_reset_state\n", idx);
        return;
    }
    
    // Reset the connection-specific CS context
    memset(&ctx[idx].counter, 0, sizeof(struct cs_count_ctx));
    k_sem_reset(&ctx[idx].sem_cs.cs_security);
    k_sem_reset(&ctx[idx].sem_cs.rrq_capabilites);
    k_sem_reset(&ctx[idx].sem_cs.create_config);
    
    printk("CS state reset for connection %d\n", idx);
}
#endif 

#if BUILD_INITIATOR 
void cs_reset_state() {
	counter.most_recent_local_ranging = PROCEDURE_COUNTER_NONE;
    counter.dropped_ranging = PROCEDURE_COUNTER_NONE;
	counter.latest_frequency_compensation = 0;
	net_buf_simple_reset(&latest_local_steps);
    net_buf_simple_reset(&latest_peer_steps);
	k_sem_reset(&sem_cs.local_steps);
	k_sem_reset(&sem_cs.rd_ready);
	k_sem_reset(&sem_cs.rd_complete);
	k_sem_reset(&sem_cs.procedure_done);
	// k_sem_reset(&sem_cs.procedure_disabled); 
}

int cs_rreq_setup(struct bt_conn *conn) {
	TRY(bt_le_cs_set_default_settings(conn , &default_settings));

    TRY(bt_ras_rreq_rd_overwritten_subscribe(conn, ranging_data_overwritten_cb));

    TRY(bt_ras_rreq_rd_ready_subscribe(conn, ranging_data_ready_cb));

    TRY(bt_ras_rreq_on_demand_rd_subscribe(conn));

    TRY(bt_ras_rreq_cp_subscribe(conn));

	TRY(bt_le_cs_read_remote_supported_capabilities(conn));  

	k_sem_take(&sem_cs.rrq_capabilites, K_FOREVER); 

	return 0; 
}
#endif 

int cs_init(struct bt_conn *conn) {
    printk("Initializing Channel Sounding...\n");

	#if BUILD_INITIATOR 
	TRY(cs_rreq_setup(conn)); 
	#endif 

	TRY(cs_procedure_configure(conn)); 

    printk("CS initialized successfully\n");
    return 0;
}

int cs_procedure_configure(struct bt_conn *conn) {
	#if BUILD_INITIATOR 
    bt_le_cs_set_valid_chmap_bits(config_params.channel_map);

	TRY(bt_le_cs_create_config(conn, &config_params,
				     BT_LE_CS_CREATE_CONFIG_CONTEXT_LOCAL_AND_REMOTE));

	k_sem_take(&sem_cs.create_config, K_FOREVER); 
	k_sem_take(&sem_cs.cs_security, K_FOREVER); 

	TRY(bt_le_cs_set_procedure_parameters(conn, &procedure_params));
	#endif 
	return 0; 
}

#if BUILD_REFLECTOR
void configure_cs_connection(struct bt_conn *conn) {
	int err = 0; 
	int idx = bt_conn_index(conn);

    printk("[CS][REFL] configure: conn=%d default settings\n", bt_conn_index(conn));
	memset(&ctx[idx].counter, 0, sizeof(struct cs_count_ctx)); 
	k_sem_reset(&ctx[idx].sem_cs.cs_security);
    k_sem_reset(&ctx[idx].sem_cs.rrq_capabilites);
    k_sem_reset(&ctx[idx].sem_cs.create_config);

	TRY(bt_le_cs_set_default_settings(conn, &default_settings)); 
}
#endif 


#if BUILD_INITIATOR
int cs_start_ranging(struct bt_conn *conn) {
	net_buf_simple_reset(&latest_local_steps);
    net_buf_simple_reset(&latest_peer_steps);
    counter.dropped_ranging = PROCEDURE_COUNTER_NONE;

	struct bt_le_cs_procedure_enable_param enable = { .config_id = ID, .enable = true };
    printk("[CS][INIT] start: conn=%d config_id=%d\n", bt_conn_index(conn), ID);
    return bt_le_cs_procedure_enable(conn, &enable);
}

int cs_stop_ranging(struct bt_conn *conn) {
	struct bt_le_cs_procedure_enable_param disable = { .config_id = ID, .enable = false };
	int err = bt_le_cs_procedure_enable(conn, &disable);

	if (err) {
		printk("Failed to disable CS procedure (err %d)\n", err);
		return err;
	}
	
	return err;
}

float cs_calc(struct bt_conn *conn) {
	float distance = 0.0f; 
	int32_t start = k_uptime_get();
	int err;

    printk("[CS][INIT] calc: wait local-done, RD ready...\n");
	err = k_sem_take(&sem_cs.procedure_done, K_SECONDS(1)); 
	if (err) {
		printk("Timeout waiting for local procedure done (err %d)\n", err); 
		return err;  
	}

    printk("[CS][INIT] get RD: pc=%d\n", counter.most_recent_peer_ranging);
	err = k_sem_take(&sem_cs.rd_ready, K_SECONDS(1));
	if (err) {
		printk("Timeout waiting for ranging data ready (err %d)\n", err);
		return err;
	}

	if (counter.most_recent_peer_ranging != counter.most_recent_local_ranging) {
		printk("Mismatch of local and peer ranging counters (%d != %d)\n",
				counter.most_recent_peer_ranging,
				counter.most_recent_local_ranging);
		return -EIO;
	}

    counter.ranging_data_err = 0;
	err = bt_ras_rreq_cp_get_ranging_data(conn, &latest_peer_steps,
			counter.most_recent_peer_ranging, ranging_data_get_complete_cb); 
    if (err) {
        printk("Failed to start getting ranging data (err %d)\n", err);
        return err;
    }

	err = k_sem_take(&sem_cs.rd_complete, K_SECONDS(1));
    if (err) {
        printk("Timeout waiting for ranging data completion (err %d)\n", err);
        return err;
    }

    if (counter.ranging_data_err) {
        return counter.ranging_data_err;
    }

	distance = estimate_distance(&latest_local_steps, &latest_peer_steps, counter.n_ap,
				  BT_CONN_LE_CS_ROLE_INITIATOR, counter.latest_frequency_compensation);
    printk("[CS][INIT] distance=%.3f m (n_ap=%u) total=%lld ms\n",
           (double)distance, counter.n_ap, (long long)(k_uptime_get() - start));
	
	return distance;
}

int cs_wait_disabled() {
	return k_sem_take(&sem_cs.procedure_disabled, K_FOREVER); 
}
#endif

================
File: lib\cs\cs.h
================
#pragma once 

#include "../global.h"
#include <zephyr/kernel.h>
#include <zephyr/types.h>
#include <zephyr/bluetooth/cs.h>
#include <zephyr/bluetooth/conn.h>
#include <bluetooth/services/ras.h>

#if BUILD_INITIATOR 
#include <calc_black_box.h>
#endif 


int cs_init(struct bt_conn *conn); 
int cs_procedure_configure(struct bt_conn *conn);

#if BUILD_REFLECTOR
void configure_cs_connection(struct bt_conn *conn); 
void cs_reset_state(struct bt_conn *conn); 
#endif

#if BUILD_INITIATOR
void cs_reset_state(); 
int cs_rreq_setup(struct bt_conn *conn); 
float cs_calc(struct bt_conn *conn);
int cs_start_ranging(struct bt_conn *conn); 
int cs_stop_ranging(struct bt_conn *conn);
int cs_wait_disabled();
#endif

/**********************************************************************/
/*                       STRUCTURES AND TYPES                         */
/**********************************************************************/

/** @brief Contains sempahores used during channel sounding */
struct cs_semaphores_ctx {
    struct k_sem cs_security; 
    struct k_sem rrq_capabilites; 
    struct k_sem create_config; 

    #if BUILD_INITIATOR 
    struct k_sem local_steps; 
    struct k_sem procedure_disabled;
    struct k_sem rd_complete; 
    struct k_sem rd_ready; 
    struct k_sem procedure_done;
    #endif 
};

/** @brief Contains counting systems */
struct cs_count_ctx { 
    #if BUILD_INITIATOR 
    int32_t most_recent_local_ranging; 
    int32_t dropped_ranging; 
    int ranging_data_err; 

    #if USING_BLACK_BOX 
    uint16_t latest_frequency_compensation; 
    int32_t most_recent_peer_ranging;
    uint8_t n_ap;
    #endif 
    #endif 
};

struct cs_ctx {
    struct cs_semaphores_ctx sem_cs; 
    struct cs_count_ctx counter; 
}; 

void cs_setup_struct_and_types(); 

/**********************************************************************/
/*                           CALLBACKS                                */
/**********************************************************************/

void remote_capabilities_cb(struct bt_conn *conn, uint8_t status, struct bt_conn_le_cs_capabilities *params); 
void security_enable_cb(struct bt_conn *conn, uint8_t status);
void config_create_cb(struct bt_conn *conn, uint8_t status, struct bt_conn_le_cs_config *config); 
void procedure_enable_cb(struct bt_conn *conn, uint8_t status, struct bt_conn_le_cs_procedure_enable_complete *params); 
void subevent_result_cb(struct bt_conn *conn, struct bt_conn_le_cs_subevent_result *result); 
void ranging_data_overwritten_cb(struct bt_conn *conn, uint16_t ranging_counter);
void ranging_data_ready_cb(struct bt_conn *conn, uint16_t ranging_counter); 
void ranging_data_get_complete_cb(struct bt_conn *conn, uint16_t ranging_counter, int err); 
void read_remote_fae_table_complete_cb(struct bt_conn *conn, uint8_t status, struct bt_conn_le_cs_fae_table *params);

================
File: lib\sync\sync.c
================
#include "sync.h"

struct sync_handler sync_ctx; 
#if BUILD_REFLECTOR 
K_FIFO_DEFINE(sheduling_fifo); 
K_THREAD_DEFINE(
    sync_thread, STACK_SIZE, scheduling_thread,
    NULL, NULL, NULL, PRIO, 0, 0); 
#endif 

int sync_init(struct sync_handler *callback) {
    if (callback) {
        sync_ctx.led_cb = callback->led_cb; 
    }
    sync_ctx.write_busy = 0; 
    sync_ctx.att_err = 0; 
    k_sem_init(&sync_ctx.sem_reflector_ack, 0, 1);
    k_sem_init(&sync_ctx.sem_write_done, 0, 1);

    k_sem_init(&sync_ctx.sem_sync_init_done, 0, 1); 
    k_sem_give(&sync_ctx.sem_sync_init_done);
    return 0; 
}

void sync_update_led(bool val) {
    if (sync_ctx.led_cb)    sync_ctx.led_cb(val); 
}

#if BUILD_INITIATOR 
int sync_request_cs(write_func_t write_fn, bool state) {
    int err;
    for(;;) {
        while ((err = write_fn(state)) == -EBUSY) k_msleep(1);      

        if (err) { k_msleep(2);    continue; }

        k_sem_take(&sync_ctx.sem_write_done, K_FOREVER);

        if (sync_ctx.att_err == BT_ATT_ERR_PREPARE_QUEUE_FULL ||
            sync_ctx.att_err == BT_ATT_ERR_UNLIKELY) {
            k_msleep(50);
            continue;
        }

        if (sync_ctx.att_err) {  
            printk("LED write failed (ATT 0x%02x)\n", sync_ctx.att_err);
            return -EIO;
        }
        break;           
    } 

    k_sem_take(&sync_ctx.sem_reflector_ack, K_FOREVER);
    return 0;
}
#endif 

void sync_reflector_ack_cb(bool state) {
    dk_set_led(USER_LED, state); 
    k_sem_give(&sync_ctx.sem_reflector_ack); 
}

bool sync_reflector_busy() {
    return !atomic_cas(&sync_ctx.write_busy, 0, 1); 
}

/**********************************************************************/
/*                              THREADS                               */
/**********************************************************************/

#if BUILD_REFLECTOR 
void scheduling_thread() {
    printk("Started scheduling thread!\n"); 
    k_sem_take(&sync_ctx.sem_sync_init_done, K_FOREVER); 

    struct fifo_container *container; 
    // int err = 0; 

    while (true) {
        container = k_fifo_get(&sheduling_fifo, K_FOREVER);
        if (!container) continue; 
        if (!container->conn) { k_free(container); continue; } 

        switch (container->val) {
            case 1: 
                container->indicate_write_func(container->conn, container->val); 
                break; 

            case 0: 
                container->indicate_write_func(container->conn, container->val); 
                break; 
            default: printk("WEIRD CASE? value %d", container->val); break; 
        }

        bt_conn_unref(container->conn); 
        k_free(container); 
    }
}

void sync_put_fifo(struct fifo_container *container) {
    k_fifo_put(&sheduling_fifo, container); 
}
#endif 

/**********************************************************************/
/*                            CALLBACKS                               */
/**********************************************************************/

void sync_ccc_changed(const struct bt_gatt_attr *attr, uint16_t value) {
    if (value == BT_GATT_CCC_INDICATE) {
        // printk("SYNC_ID indications enabled by client.\n");
    } else if (value == BT_GATT_CCC_NOTIFY) {
        // printk("SYNC_ID notifications enabled by client.\n");
    } else if (value == 0) {
        // printk("SYNC_ID notifications/indications disabled by client.\n");
    } else {
        printk("SYNC_ID CCCD changed to unknown value: 0x%04x\n", value);
    }
}

void sync_write_cb(struct bt_conn *conn, uint8_t err,
                    struct bt_gatt_write_params *params) {
    sync_ctx.write_busy = 0; 
    sync_ctx.att_err = err; 
    k_sem_give(&sync_ctx.sem_write_done);

    if (err != 0x00 && err != BT_ATT_ERR_PREPARE_QUEUE_FULL) {
        printk("SYNC_ID write failed  (ATT 0x%02x)\n", err); 
    }
}

uint8_t sync_id_indicated(struct bt_conn *conn, struct bt_gatt_subscribe_params *params, 
    const void *data, uint16_t length) {
    if (data == NULL) {
        printk("Unsubscribed from SYNC_ID indications\n");
        params->value_handle = 0;
        return BT_GATT_ITER_STOP;
    }

    if (length != sizeof(uint8_t)) {
        printk("Received SYNC_ID indication with invalid length: %d\n", length);
        return BT_GATT_ITER_CONTINUE;
    }

    uint8_t received_value = *((uint8_t *)data);
    // printk("Received SYNC_ID indication from server: %d\n", received_value);

    #if BUILD_INITIATOR 
        k_sem_give(&sync_ctx.sem_reflector_ack);
    #endif 
    
    /* Update local state */
    if (sync_ctx.led_cb) {
        sync_ctx.led_cb(received_value ? true : false);
    }
    
    return BT_GATT_ITER_CONTINUE;
}

================
File: lib\sync\sync.h
================
#pragma once 

#include <zephyr/kernel.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/gatt.h>
#include <zephyr/bluetooth/uuid.h>
#include <dk_buttons_and_leds.h>
#include <zephyr/bluetooth/cs.h>
#include "../global.h"

#define USER_LED DK_LED4
#define PRIO 5
#define STACK_SIZE 1024


/**********************************************************************/
/*                       STRUCTURES AND TYPES                         */
/**********************************************************************/

/** @brief Higher-order function used to update the led during indication */
typedef void (*led_cb_t)(const bool led_state); 

/** @brief higher-order function used for requesting writing */
typedef int (*write_func_t)(bool state); 

/** @brief higher-order function used for configuring CS */
typedef void (*configure_func_t)(struct bt_conn *conn); 

/** @brief higher-order function used for configuring CS */
typedef void (*indicate_func_t)(struct bt_conn *conn, uint8_t val); 

/** @brief Contains context used to control multiple initiators */
struct sync_handler {
    led_cb_t led_cb;
    atomic_t write_busy; 
    uint8_t att_err; 
    struct k_sem sem_write_done; 
    struct k_sem sem_reflector_ack; 
    struct k_sem sem_sync_init_done;
}; 

/** @brief Contains info about the current active CS initator */
struct fifo_container {
    void *fifo_reserved; 
    configure_func_t configure_cs_func; 
    indicate_func_t indicate_write_func;
    struct bt_conn *conn; 
    uint8_t val; 
};

#define FIFO_CONTAINER_DEFINE(name, cfg, ind, _conn, _val)        \
    struct fifo_container *name = k_malloc(sizeof(*name));        \
    if (name) {                                                   \
        name->configure_cs_func    = (cfg);                       \
        name->indicate_write_func  = (ind);                       \
        name->val                  = (_val);                      \
        name->conn                 = bt_conn_ref(_conn);          \
    }
    
/**********************************************************************/
/*                              GENERAL                               */
/**********************************************************************/
ssize_t sync_write_id(struct bt_conn *conn, const struct bt_gatt_attr *attr, 
	const void *buf, uint16_t len, uint16_t offset, uint8_t flags); 
int sync_init(struct sync_handler *callback);
int sync_request_cs(write_func_t write_fn, bool state);
void sync_update_led(bool val); 
bool sync_reflector_busy(); 

/**********************************************************************/
/*                              THREADS                               */
/**********************************************************************/
void scheduling_thread(); 
void sync_put_fifo(struct fifo_container *container); 

/**********************************************************************/
/*                            CALLBACKS                               */
/**********************************************************************/

void sync_write_cb(struct bt_conn *conn, uint8_t err, struct bt_gatt_write_params *params);
uint8_t sync_id_indicated(struct bt_conn *conn, struct bt_gatt_subscribe_params *params, 
    const void *data, uint16_t length);
void sync_ccc_changed(const struct bt_gatt_attr *attr, uint16_t value); 
void sync_reflector_ack_cb(bool state);

================
File: projects\initator_build\CMakeLists.txt
================
cmake_minimum_required(VERSION 3.20.0)
find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})

project(initiator)
add_subdirectory(../../lib lib)
target_sources(app PRIVATE ../../src/initator.c)
target_link_libraries(app PRIVATE cs ble calc black_box)
target_include_directories(app PRIVATE ../../lib)

================
File: projects\initator_build\Kconfig
================
mainmenu "Channel sounding Application"

config CS_BUILD_INITIATOR
  bool "Build the project as an initiator for CS"
  default n
  help
    Correctly assigns libraries to build initiator

config CS_BUILD_REFLECTOR
  bool "Build the project as a reflector for CS"
  default n
  help
    Correctly assigns libraries to build reflector

config CS_BLACK_BOX_CALC
  bool "Allow using black box solution for calculating the distance during Channel Sounding"
  default n
  help
    Assigns black box method to calculate Channel Sounding

config CS_CALC
  bool "Enable sample solution for calculating the distance during Channel Sounding"
  default n
  help
    Selecting this assigns the sample method to calculate Channel Sounding
  select FPU
  select FPU_SHARING
  select BT_CS_DE
  select BT_CS_DE_512_NFFT

config THREAD_CHECK
  bool "Enable thread-analyzer and extra stack instrumentation"
  default n
  help
    Activates Zephyr's built-in thread analyzer, which automatically
    reports stack sizes and thread names during runtime
  select THREAD_ANALYZER
  select THREAD_ANALYZER_AUTO
  select INIT_STACKS
  select THREAD_NAME

config TAG_PRINT
  bool "Enable RTT print for tag"
  default n 
  help
     Enables RTT for logging  
  select USE_SEGGER_RTT 
  select LOG
  select LOG_BACKEND_RTT
  select LOG_PROCESS_THREAD
  select RTT_CONSOLE

config DK_PRINT 
  bool "Enable UART print for dk"
  default n 
  help
     Enables UART for logging
  select SERIAL 
  select UART_CONSOLE

source "Kconfig.zephyr"

================
File: projects\initator_build\prj.conf
================
#
# Copyright (c) 2024 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

######################################################
#               Generic configuration
######################################################
CONFIG_DK_LIBRARY=y
CONFIG_MAIN_STACK_SIZE=16384
CONFIG_HEAP_MEM_POOL_SIZE=24000
CONFIG_CS_BUILD_INITIATOR=y 
CONFIG_BT_DEVICE_NAME="5678"
CONFIG_REBOOT=y
CONFIG_ASSERT=n
CONFIG_DEBUG=n

######################################################
#                     Logging 
######################################################
# CONFIG_TAG_PRINT=n
# CONFIG_LOG_MODE_DEFERRED=n
# CONFIG_LOG_DEFAULT_LEVEL=3
CONFIG_DK_PRINT=y

######################################################
#                  Thread analyser
######################################################
CONFIG_THREAD_CHECK=n

######################################################
#                   Bluetooth 
######################################################
CONFIG_BT=y
CONFIG_BT_SMP=y
CONFIG_BT_PERIPHERAL=y 
CONFIG_BT_MAX_CONN=1
CONFIG_BT_BONDABLE=n
CONFIG_BT_CTLR_TX_PWR_PLUS_8=y
CONFIG_BT_USER_PHY_UPDATE=y
CONFIG_BT_L2CAP_TX_MTU=498
CONFIG_BT_BUF_ACL_TX_SIZE=502
CONFIG_BT_BUF_ACL_RX_SIZE=502
CONFIG_BT_ATT_PREPARE_COUNT=3
CONFIG_BT_CTLR_DATA_LENGTH_MAX=251
CONFIG_BT_CTLR_PHY_2M=y
CONFIG_BT_PHY_UPDATE=y
CONFIG_BT_USER_DATA_LEN_UPDATE=y
CONFIG_BT_CTLR_SDC_LLPM=y
CONFIG_BT_GAP_AUTO_UPDATE_CONN_PARAMS=n 
CONFIG_BT_REMOTE_INFO=y
CONFIG_BT_CTLR_CONN_RSSI=y
CONFIG_BT_CTLR_ADVANCED_FEATURES=y

######################################################
#                Channel sounding 
######################################################
CONFIG_BT_GATT_CLIENT=y
CONFIG_BT_GATT_DYNAMIC_DB=y
CONFIG_BT_CHANNEL_SOUNDING=y
CONFIG_BT_RAS=y
CONFIG_BT_RAS_RREQ=y
CONFIG_BT_RAS_MODE_3_SUPPORTED=n
CONFIG_BT_RAS_MAX_ANTENNA_PATHS=1
CONFIG_BT_CTLR_SDC_CS_MAX_ANTENNA_PATHS=1
CONFIG_BT_CTLR_SDC_CS_NUM_ANTENNAS=1
CONFIG_BT_CHANNEL_SOUNDING_REASSEMBLY_BUFFER_CNT=1
CONFIG_BT_CTLR_SDC_CS_STEP_MODE3=n
CONFIG_BT_CHANNEL_SOUNDING_REASSEMBLY_BUFFER_SIZE=5000
CONFIG_BT_TRANSMIT_POWER_CONTROL=y
CONFIG_BT_CTLR_SDC_CS_COUNT=1

######################################################
#                 CS Calculation  
######################################################
CONFIG_FPU=y
CONFIG_CS_BLACK_BOX_CALC=y
CONFIG_CBPRINTF_FP_SUPPORT=y

================
File: projects\reflector_build\CMakeLists.txt
================
cmake_minimum_required(VERSION 3.20.0)
find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})

project(reflector)
add_subdirectory(../../lib lib)
target_sources(app PRIVATE ../../src/reflector.c)
target_link_libraries(app PRIVATE cs ble calc sync)
target_include_directories(app PRIVATE ../../lib)

================
File: projects\reflector_build\Kconfig
================
mainmenu "Channel sounding Application"

config CS_BUILD_INITIATOR
  bool "Build the project as an initiator for CS"
  default n
  help
    Correctly assigns libraries to build initiator

config CS_BUILD_REFLECTOR
  bool "Build the project as a reflector for CS"
  default n
  help
    Correctly assigns libraries to build reflector

config CS_BLACK_BOX_CALC
  bool "Allow using black box solution for calculating the distance during Channel Sounding"
  default n
  help
    Assigns black box method to calculate Channel Sounding

config CS_CALC
  bool "Enable sample solution for calculating the distance during Channel Sounding"
  default n
  help
    Selecting this assigns the sample method to calculate Channel Sounding
  select FPU
  select FPU_SHARING
  select BT_CS_DE
  select BT_CS_DE_512_NFFT

config THREAD_CHECK
  bool "Enable thread-analyzer and extra stack instrumentation"
  default n
  help
    Activates Zephyr's built-in thread analyzer, which automatically
    reports stack sizes and thread names during runtime
  select THREAD_ANALYZER
  select THREAD_ANALYZER_AUTO
  select INIT_STACKS
  select THREAD_NAME

config TAG_PRINT
  bool "Enable RTT print for tag"
  default n 
  help
     Enables RTT for logging  
  select USE_SEGGER_RTT 
  select LOG
  select LOG_BACKEND_RTT
  select LOG_PROCESS_THREAD
  select RTT_CONSOLE

config DK_PRINT 
  bool "Enable UART print for dk"
  default n 
  help
     Enables UART for logging
  select SERIAL 
  select UART_CONSOLE

source "Kconfig.zephyr"

================
File: projects\reflector_build\prj.conf
================
#
# Copyright (c) 2024 Nordic Semiconductor ASA
#
# SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
#

######################################################
#               Generic configuration
######################################################
CONFIG_DK_LIBRARY=y
CONFIG_CS_BUILD_REFLECTOR=y 
CONFIG_MAIN_STACK_SIZE=16384

######################################################
#                   Bluetooth 
######################################################
CONFIG_BT=y
CONFIG_BT_CENTRAL=y
CONFIG_BT_LL_SOFTDEVICE=y
CONFIG_BT_SMP=y
CONFIG_BT_DEVICE_NAME="1234"
CONFIG_BT_MAX_CONN=4
CONFIG_BT_GAP_AUTO_UPDATE_CONN_PARAMS=n 
CONFIG_BT_BONDABLE=y
CONFIG_BT_MAX_PAIRED=4
CONFIG_BT_SCAN=y
CONFIG_BT_SCAN_FILTER_ENABLE=y
CONFIG_BT_SCAN_NAME_CNT=1
CONFIG_BT_L2CAP_TX_MTU=402
CONFIG_HEAP_MEM_POOL_SIZE=24000
CONFIG_BT_L2CAP_TX_BUF_COUNT=16
CONFIG_BT_BUF_ACL_TX_SIZE=502
CONFIG_BT_BUF_ACL_RX_SIZE=502
CONFIG_BT_CTLR_DATA_LENGTH_MAX=251
CONFIG_BT_CTLR_PHY_2M=y
CONFIG_BT_USER_PHY_UPDATE=y
CONFIG_BT_GATT_CLIENT=y # TODO: MAYBE REMOVE 
CONFIG_BT_GATT_DYNAMIC_DB=y # TODO: MAYBE REMOVE 
CONFIG_BT_CTLR_SDC_LLPM=y
CONFIG_BT_CTLR_SDC_MAX_CONN_EVENT_LEN_DEFAULT=6000
CONFIG_BT_CTLR_SDC_CONN_EVENT_EXTEND_DEFAULT=y
CONFIG_BT_CTLR_SDC_CENTRAL_ACL_EVENT_SPACING_DEFAULT=7500

######################################################
#                Channel sounding 
######################################################
CONFIG_BT_CHANNEL_SOUNDING=y
CONFIG_BT_RAS=y
CONFIG_BT_RAS_RRSP=y
CONFIG_BT_CTLR_SDC_CS_COUNT=4
CONFIG_BT_RAS_MODE_3_SUPPORTED=n
CONFIG_BT_RAS_MAX_ANTENNA_PATHS=1
CONFIG_BT_CTLR_SDC_CS_MAX_ANTENNA_PATHS=1
CONFIG_BT_CTLR_SDC_CS_NUM_ANTENNAS=1
CONFIG_BT_CTLR_SDC_CS_STEP_MODE3=n
CONFIG_BT_CHANNEL_SOUNDING_REASSEMBLY_BUFFER_SIZE=5600
CONFIG_BT_CHANNEL_SOUNDING_REASSEMBLY_BUFFER_CNT=2
CONFIG_BT_TRANSMIT_POWER_CONTROL=y

================
File: src\initator.c
================
#include <ble.h>

struct bt_conn *conn; 
K_SEM_DEFINE(init_done_sem, 0, 1);

static struct sync_handler cb = {
    .led_cb = sync_reflector_ack_cb,
};

void acquisition_thread() {
    float distance = 0;
    struct bt_conn *c = NULL;

	k_sem_take(&init_done_sem, K_FOREVER);

    c = conn; 
	if (!c) {
		printk("Connection is NULL even after init. Aborting.\n");
		return;
	}

	printk("Connection ready. Starting measurement loop.\n");

	while (true) {
        if(!c)  { k_msleep(50); continue;}

        if(sync_reflector_busy()) { continue; }

        TRY(sync_request_cs(ble_write, true));

	    cs_reset_state(); 
        TRY(cs_start_ranging(c)); 
        distance = cs_calc(c);
        // TRY(cs_stop_ranging(c)); 
        // TRY(cs_wait_disabled());
        TRY(sync_request_cs(ble_write, false));
	}

}

int main(void) {
    printk("Starting Nordic CS Initiator...\n");

    conn = ble_init(); 
    TRY(cs_init(conn));
    TRY_RETURN(sync_init(&cb)); 

	printk("Setup complete. Handing over to acquisition thread.\n");
	k_sem_give(&init_done_sem);
    return 0;
}

K_THREAD_DEFINE(
    acquisition, 16384, acquisition_thread, 
    NULL, NULL, NULL, 7, 0, 0
);

================
File: src\reflector.c
================
#include <ble.h>

#define USER_LED DK_LED4

static void app_led_cb(bool led_state) {
	dk_set_led(USER_LED, led_state); 
  // TRY(bt_le_scan_stop());  // TODO: use semaphore or other thread safe method just in case
}

static struct sync_handler cb = {
  .led_cb = app_led_cb,
};

int main(void) {
  printk("Starting Nordic CS Reflector...\n");

  TRY_RETURN(sync_init(&cb)); 
  ble_init();

  while (true) {
    // ble_connections_handler(); 
    k_msleep(10);
  }
  return 0;
}
